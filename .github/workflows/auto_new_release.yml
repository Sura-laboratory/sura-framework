name: Create Release

on:
  push:
    branches:
      - main

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract labels from merged PRs
        id: pr-labels
        if: github.event_name == 'pull_request'
        run: |
          PR_LABELS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/labels" \
            | jq -r '.[]?.name' || echo "")
          echo "labels=$PR_LABELS" >> $GITHUB_OUTPUT

      - name: Determine next semantic version
        id: version
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT

          PR_LABELS="${{ steps.pr-labels.outputs.labels }}"
          if [ -n "$PR_LABELS" ]; then
            if echo "$PR_LABELS" | grep -q "release/major"; then
              NEW_VERSION=$(echo $LAST_TAG | perl -pe 's/v(\d+)\.(\d+)\.(\d+)/"v".($1+1).".0.0"/e')
            elif echo "$PR_LABELS" | grep -q "release/minor"; then
              NEW_VERSION=$(echo $LAST_TAG | perl -pe 's/v(\d+)\.(\d+)\.(\d+)/"v".$1.".".($2+1).".0"/e')
            elif echo "$PR_LABELS" | grep -q "release/patch"; then
              NEW_VERSION=$(echo $LAST_TAG | perl -pe 's/v(\d+)\.(\d+)\.(\d+)/"v".$1.".".$2.".".($3+1)/e')
            else
              NEW_VERSION=""
            fi
          else
            NEW_VERSION=""
          fi

          if [ -z "$NEW_VERSION" ]; then
            COMMITS_SINCE_LAST=$(git log $LAST_TAG..HEAD --oneline)
            HAS_FEAT=$(echo "$COMMITS_SINCE_LAST" | grep -Ei "^feat[(:]" || echo "")
            HAS_FIX=$(echo "$COMMITS_SINCE_LAST" | grep -Ei "^fix[(:]" || echo "")

            if [ -n "$HAS_FEAT" ]; then
              NEW_VERSION=$(echo $LAST_TAG | perl -pe 's/v(\d+)\.(\d+)\.(\d+)/"v".$1.".".($2+1).".0"/e')
            elif [ -n "$HAS_FIX" ]; then
              NEW_VERSION=$(echo $LAST_TAG | perl -pe 's/v(\d+)\.(\d+)\.(\d+)/"v".$1.".".$2.".".($3+1)/e')
            else
              NEW_VERSION=$(echo $LAST_TAG | perl -pe 's/v(\d+)\.(\d+)\.(\d+)/"v".$1.".".$2.".".($3+1)/e')
            fi
          fi

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_type=$(echo $NEW_VERSION | cut -d'.' -f2-)" >> $GITHUB_OUTPUT

      - name: Generate release notes with authors
        id: release-notes
        run: |
          LAST_TAG=${{ steps.version.outputs.last_tag }}
          NEW_VERSION=${{ steps.version.outputs.new_version }}

          # –°–æ–±–∏—Ä–∞–µ–º –∫–æ–º–º–∏—Ç—ã —Å –∞–≤—Ç–æ—Ä–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
          FEAT_COMMITS=""
          FIX_COMMITS=""
          PERF_COMMITS=""
          REFACTOR_COMMITS=""
          OTHER_COMMITS=""

          while IFS= read -r line; do
            COMMIT_MSG=$(echo "$line" | cut -d'|' -f1)
            AUTHOR=$(echo "$line" | cut -d'|' -f2)

            if [[ "$COMMIT_MSG" =~ ^feat\(.*\): ]]; then
              FEAT_COMMITS+="- ${COMMIT_MSG//feat\(*\):/**} (${AUTHOR})\n"
            elif [[ "$COMMIT_MSG" =~ ^fix\(.*\): ]]; then
              FIX_COMMITS+="- ${COMMIT_MSG//fix\(*\):/**} (${AUTHOR})\n"
            elif [[ "$COMMIT_MSG" =~ ^perf\(.*\): ]]; then
              PERF_COMMITS+="- ${COMMIT_MSG//perf\(*\):/**} (${AUTHOR})\n"
            elif [[ "$COMMIT_MSG" =~ ^refactor\(.*\): ]]; then
              REFACTOR_COMMITS+="- ${COMMIT_MSG//refactor\(*\):/**} (${AUTHOR})\n"
            else
              OTHER_COMMITS+="- $COMMIT_MSG (${AUTHOR})\n"
            fi
          done < <(git log $LAST_TAG..HEAD --pretty=format:"%s|%an" | grep -v '^Merge')

          RELEASE_BODY=""

          if [ -n "$FEAT_COMMITS" ]; then
            RELEASE_BODY+="### üöÄ –ù–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (Features)\n$FEAT_COMMITS\n"
          fi

          if [ -n "$FIX_COMMITS" ]; then
            RELEASE_BODY+="### üõ† –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è (Fixes)\n$FIX_COMMITS\n"
          fi

          if [ -n "$PERF_COMMITS" ]; then
            RELEASE_BODY+="### ‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (Performance)\n$PERF_COMMITS\n"
          fi

          if [ -n "$REFACTOR_COMMITS" ]; then
            RELEASE_BODY+="### üîÅ –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ (Refactoring)\n$REFACTOR_COMMITS\n"
          fi

          if [ -n "$OTHER_COMMITS" ]; then
            RELEASE_BODY+="### üìÉ –ü—Ä–æ—á–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è\n$OTHER_COMMITS\n"
          fi

          if [ -z "$RELEASE_BODY" ]; then
            RELEASE_BODY="–í —ç—Ç–æ–º —Ä–µ–ª–∏–∑–µ –Ω–µ—Ç –∑–Ω–∞—á–∏–º—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π."
          else
            RELEASE_BODY="${RELEASE_BODY}---\n*–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–º–º–∏—Ç–æ–≤ –∏ –º–µ—Ç–æ–∫ PR.*"
          fi

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.new_version }}
          name: Release ${{ steps.version.outputs.new_version }}
          body: ${{ steps.release-notes.outputs.body }}
          draft: false
          prerelease: false
